name: Create experiment from issue

on:
  issues:
    types: [opened, edited, labeled]
  workflow_dispatch: {}  # Manual "Run workflow" button

permissions:
  contents: write
  issues: write

jobs:
  create:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repo
        uses: actions/checkout@v4

      - name: Ensure label exists (new-experiment)
        uses: actions/github-script@v7
        with:
          script: |
            const labelName = "new-experiment";
            try {
              await github.rest.issues.getLabel({...context.repo, name: labelName});
            } catch {
              await github.rest.issues.createLabel({
                ...context.repo,
                name: labelName,
                color: "0e8a16",
                description: "Triggers experiment folder creation"
              });
            }

      - name: Auto-label issue if it looks like the form
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue?.body || "";
            const hasHeader = body.includes("### Project Title");
            const hasLabel = (context.payload.issue?.labels || []).some(l => l.name === "new-experiment");
            if (hasHeader && !hasLabel) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: context.issue.number,
                labels: ["new-experiment"]
              });
            }

      - name: Short-circuit unless this is our form
        id: gate
        run: |
          body="${{ github.event.issue.body || '' }}"
          if echo "$body" | grep -q "### Project Title"; then
            echo "ok=true" >> $GITHUB_OUTPUT
          else
            echo "ok=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop if not our issue
        if: steps.gate.outputs.ok != 'true'
        run: echo "This issue doesn't look like the New experiment form. Skipping."

      - name: Set up Python deps
        if: steps.gate.outputs.ok == 'true'
        run: |
          python3 -m pip install --quiet pyyaml

      - name: Parse Issue Form → JSON payload (with debug)
        if: steps.gate.outputs.ok == 'true'
        id: parse
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          python3 - <<'PY'
          import os, re, json, yaml, sys, unicodedata

          body = os.environ.get("ISSUE_BODY", "")

          def clean(v:str) -> str:
            v = (v or "").strip()
            lower = v.lower()
            if lower in {"_no response_", "no response", "(none)", "none", "n/a", "na"}:
              return ""
            return v

          def get_block(label:str) -> str:
            m = re.search(rf"^### {re.escape(label)}\s*\n\n([\s\S]*?)(?=\n^### |\Z)", body, re.M)
            if not m:
              return ""
            val = m.group(1).strip()
            if val.startswith("```") and val.endswith("```"):
              val = "\n".join(val.splitlines()[1:-1]).strip()
            return clean(val)

          def slugify(text:str) -> str:
            text = text or ""
            text = unicodedata.normalize('NFKD', text)
            text = text.encode('ascii', 'ignore').decode('ascii')
            # Keep letters, numbers, space, underscore, hyphen; drop others
            text = re.sub(r"[^a-zA-Z0-9\s_-]", "", text)
            text = text.strip().lower()
            text = re.sub(r"[\s_]+", "-", text)
            text = re.sub(r"-+", "-", text)
            return text.strip('-')

          data = {
            # Updated labels from issue form
            "title":       clean(get_block("Project Title")),
            "description": clean(get_block("Description")),
            "status":      clean(get_block("Status")) or "draft",
          }

          authors = [a.strip() for a in clean(get_block("Authors (comma-separated)")).split(",") if a.strip()]
          tags    = [t.strip() for t in clean(get_block("Tags (comma-separated)")).split(",") if t.strip()]
          if authors: data["authors"] = authors
          if tags:    data["tags"] = tags

          # Map new single-value fields
          dp_name = clean(get_block("DataPipe Name"))
          if dp_name:
            data.setdefault("data", {})["datapipe_name"] = dp_name

          osf_link = clean(get_block("OSF Link"))
          if osf_link:
            data.setdefault("links", {})["osf"] = osf_link

          for key,label in [
            ("links",    "Links (YAML)"),
            ("sample",   "Sample (YAML, optional)"),
            ("measures", "Measures (YAML list, optional)"),
          ]:
            raw = get_block(label)
            if raw:
              try:
                val = yaml.safe_load(raw)
                if val is not None:
                  data[key] = val
              except Exception:
                pass

          extra = get_block("Extra YAML (optional)")
          if extra:
            try:
              more = yaml.safe_load(extra)
              if isinstance(more, dict):
                data.update(more)
            except Exception:
              pass

          # Debug table
          def dbg(key): return data.get(key, "")
          print("Parsed fields:")
          print(f"  title       : {dbg('title')}")
          print(f"  status      : {dbg('status')}")
          print(f"  authors     : {dbg('authors')}")
          print(f"  tags        : {dbg('tags')}")

          # Ensure we have a stable id; derive from title if missing
          if not data.get("id"):
            if data.get("title"):
              data["id"] = slugify(data["title"]) or None
            if not data.get("id"):
              print("::error::Missing title to derive experiment id.")
              sys.exit(1)
          print(f"  id          : {dbg('id')}")

          payload = json.dumps(data, ensure_ascii=False)
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
            fh.write("payload<<EOF\n"); fh.write(payload); fh.write("\nEOF\n")
          PY

      - name: Create/merge metadata.yml in experiments/<id>/
        if: steps.gate.outputs.ok == 'true'
        env:
          PAYLOAD: ${{ steps.parse.outputs.payload }}
        run: |
          python3 - <<'PY'
          import os, json, yaml, datetime, pathlib
          data = json.loads(os.environ["PAYLOAD"])
          eid  = data["id"]
          base_dir = pathlib.Path("experiments") / eid
          meta_path = base_dir / "metadata.yml"
          base_dir.mkdir(parents=True, exist_ok=True)
          if meta_path.exists():
            meta = yaml.safe_load(open(meta_path, "r", encoding="utf-8")) or {}
          else:
            meta = {"id": eid, "version": "1.0.0", "date_created": datetime.date.today().isoformat()}
          meta.update(data)
          meta["date_updated"] = datetime.date.today().isoformat()
          with open(meta_path, "w", encoding="utf-8") as f:
            yaml.safe_dump(meta, f, sort_keys=False, allow_unicode=True)
          PY

      - name: Commit files
        if: steps.gate.outputs.ok == 'true'
        run: |
          git config user.name  "github-actions"
          git config user.email "actions@github.com"
          # Stage changes under experiments/, tolerate no matches
          git add -A experiments 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Create/update experiment metadata from issue"
            # Make sure branch is up to date before pushing
            git pull --rebase origin main
            git push origin main
          fi

      - name: Comment back on issue (success)
        if: steps.gate.outputs.ok == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const payload = JSON.parse(core.getInput('payload'));
            const id = payload.id;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: `✅ Created/updated \`experiments/${id}/metadata.yml\`. The catalog will rebuild automatically.`
            });
          payload: ${{ steps.parse.outputs.payload }}
